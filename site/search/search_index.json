{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"draw/","text":"Code Explanation \u00b6 This code demonstrates how to download a CSV file from an API, load it into a pandas DataFrame, and perform graph operations using the NetworkX library. Import necessary libraries: requests for making HTTP requests to download the CSV file. networkx as nx for creating and manipulating graphs. pandas as pd for working with tabular data. datetime for dealing with date and time operations. Flask for building web applications. Set the date for user input. Make an HTTP request to download a CSV file from a specific URL using the requests.get() function. The response is saved in the response variable. Check if the request was successful by verifying the status code of the response. If it is 200, save the response content to a file named \"tgvmax-auto.csv\". If it is not 200, print a failure message. Load the downloaded CSV file into a pandas DataFrame using the pd.read_csv() function. The parameters sep=';' and encoding='utf-8' are provided to specify the delimiter and encoding of the CSV file, respectively. Filter the DataFrame based on user input and specific columns. Drop unnecessary columns from the DataFrame using the df.drop() function. Create an empty multigraph using nx.MultiDiGraph() . Get a set of all unique station names from the \"origine\" and \"destination\" columns of the DataFrame. Add each station as a node in the graph using the G.add_node(station) function. Iterate through each row of the DataFrame and create edges in the graph using the G.add_edge() function. Define a function named find_all_paths() to find all paths from the start station to the end station with a maximum number of hops. In the find_all_paths() function: Declare an empty list to store all paths. Define a recursive inner function named dfs() to explore the graph. In the dfs() function: Base case: if the current station is the end station, append the current path to the list of all paths and reset the number of hops. Explore the neighbors of the current station by iterating through the outgoing edges using the G.edges() function. Check if the neighbor station has not been visited previously in the current path. Check if the number of hops is less than the maximum allowed hops. Compare the departure and arrival times of the current train with the previous train to ensure a valid connection between stations. Recursively call the dfs() function with the neighbor station, incremented hops, and updated path. Call the dfs() function starting from the start station with initial hops as 0 and the path containing only the start station. Return the list of all paths. Example usage: Set the start station, end station, and maximum number of hops. Call the find_all_paths() function with the defined parameters. If paths are found, print each path. Otherwise, print a message indicating that no paths were found. Example Output \u00b6 Path: [('MARSEILLE ST CHARLES', datetime.time(0, 0), 0), ('AVIGNON TGV', datetime.time(15, 58), 0), ('LYON PART DIEU', datetime.time(17, 54), 0), ('LYON PERRACHE', datetime.time(19, 0), 0), ('\u3007 LYON (intramuros)', datetime.time(19, 2), 0), ('\u3007 LYON (...) Path: [('MARSEILLE ST CHARLES', datetime.time(0, 0), 0), ('AVIGNON TGV', datetime.time(15, 58), 0), ('LYON PART DIEU', datetime.time(17, 54), 0), ('LYON PERRACHE', datetime.time(19, 0), 0), ('\u3007 LYON (intramuros)', datetime.time(19, 2), 1), ('LYON ((...) Path: [('MARSEILLE ST CHARLES', datetime.time(0, 0), 0), ('AVIGNON TGV', datetime.time(15, 58), 0), ('LYON PART DIEU', datetime.time(17, 54), 0), ('LYON PERRACHE', datetime.time(19, 0), 0), ('\u3007 LYON (intramuros)', datetime.time(19, 2), 1), ('LYON ((...) ... (truncated for brevity)","title":"Draw"},{"location":"draw/#code-explanation","text":"This code demonstrates how to download a CSV file from an API, load it into a pandas DataFrame, and perform graph operations using the NetworkX library. Import necessary libraries: requests for making HTTP requests to download the CSV file. networkx as nx for creating and manipulating graphs. pandas as pd for working with tabular data. datetime for dealing with date and time operations. Flask for building web applications. Set the date for user input. Make an HTTP request to download a CSV file from a specific URL using the requests.get() function. The response is saved in the response variable. Check if the request was successful by verifying the status code of the response. If it is 200, save the response content to a file named \"tgvmax-auto.csv\". If it is not 200, print a failure message. Load the downloaded CSV file into a pandas DataFrame using the pd.read_csv() function. The parameters sep=';' and encoding='utf-8' are provided to specify the delimiter and encoding of the CSV file, respectively. Filter the DataFrame based on user input and specific columns. Drop unnecessary columns from the DataFrame using the df.drop() function. Create an empty multigraph using nx.MultiDiGraph() . Get a set of all unique station names from the \"origine\" and \"destination\" columns of the DataFrame. Add each station as a node in the graph using the G.add_node(station) function. Iterate through each row of the DataFrame and create edges in the graph using the G.add_edge() function. Define a function named find_all_paths() to find all paths from the start station to the end station with a maximum number of hops. In the find_all_paths() function: Declare an empty list to store all paths. Define a recursive inner function named dfs() to explore the graph. In the dfs() function: Base case: if the current station is the end station, append the current path to the list of all paths and reset the number of hops. Explore the neighbors of the current station by iterating through the outgoing edges using the G.edges() function. Check if the neighbor station has not been visited previously in the current path. Check if the number of hops is less than the maximum allowed hops. Compare the departure and arrival times of the current train with the previous train to ensure a valid connection between stations. Recursively call the dfs() function with the neighbor station, incremented hops, and updated path. Call the dfs() function starting from the start station with initial hops as 0 and the path containing only the start station. Return the list of all paths. Example usage: Set the start station, end station, and maximum number of hops. Call the find_all_paths() function with the defined parameters. If paths are found, print each path. Otherwise, print a message indicating that no paths were found.","title":"Code Explanation"},{"location":"draw/#example-output","text":"Path: [('MARSEILLE ST CHARLES', datetime.time(0, 0), 0), ('AVIGNON TGV', datetime.time(15, 58), 0), ('LYON PART DIEU', datetime.time(17, 54), 0), ('LYON PERRACHE', datetime.time(19, 0), 0), ('\u3007 LYON (intramuros)', datetime.time(19, 2), 0), ('\u3007 LYON (...) Path: [('MARSEILLE ST CHARLES', datetime.time(0, 0), 0), ('AVIGNON TGV', datetime.time(15, 58), 0), ('LYON PART DIEU', datetime.time(17, 54), 0), ('LYON PERRACHE', datetime.time(19, 0), 0), ('\u3007 LYON (intramuros)', datetime.time(19, 2), 1), ('LYON ((...) Path: [('MARSEILLE ST CHARLES', datetime.time(0, 0), 0), ('AVIGNON TGV', datetime.time(15, 58), 0), ('LYON PART DIEU', datetime.time(17, 54), 0), ('LYON PERRACHE', datetime.time(19, 0), 0), ('\u3007 LYON (intramuros)', datetime.time(19, 2), 1), ('LYON ((...) ... (truncated for brevity)","title":"Example Output"},{"location":"main/","text":"Flask App \u00b6 This is a Flask web application that allows users to search for train paths between two stations. It uses the pandas library to read train data from a CSV file, and the networkx library to represent the train network as a graph. Installation \u00b6 To run this app, you need to have Flask, pandas, networkx, and requests installed. You can install them using the following command: pip install flask pandas networkx requests Usage \u00b6 To run the app, execute the following command in your terminal: python app.py This will start the Flask development server, and the app will be available at http://localhost:5000 . API Endpoints \u00b6 / \u00b6 This endpoint displays the home page of the app. It renders the index.html template and passes a list of station names to the template. /search \u00b6 This endpoint is triggered when the user submits the search form on the home page. It reads the user's inputs and performs a search for train paths between the specified start and end stations. The train data is downloaded from the SNCF API and stored in a pandas DataFrame. The search is then performed using the find_all_paths() function, which uses a recursive depth-first search algorithm to explore the train network graph. The search results are rendered in the search.html template and displayed to the user. Function: find_all_paths() \u00b6 This function takes in a network graph G , a start station name, an end station name, and the maximum number of hops, and returns a list of all paths between the start and end stations within the specified maximum number of hops. It uses a recursive depth-first search algorithm to explore the graph and find all possible paths. The algorithm keeps track of the number of hops made so far and the path taken. When the end station is reached, the current path is added to the list of all paths found. Templates \u00b6 The app uses two HTML templates: index.html and search.html . The index.html template displays a form for the user to enter their search criteria, and a dropdown menu to select the start and end stations. The search.html template displays the search results in a table format. Dependencies \u00b6 This app has the following dependencies: Flask: A micro web framework for Python pandas: A library for data manipulation and analysis networkx: A library for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks requests: A library for making HTTP requests","title":"Flask App"},{"location":"main/#flask-app","text":"This is a Flask web application that allows users to search for train paths between two stations. It uses the pandas library to read train data from a CSV file, and the networkx library to represent the train network as a graph.","title":"Flask App"},{"location":"main/#installation","text":"To run this app, you need to have Flask, pandas, networkx, and requests installed. You can install them using the following command: pip install flask pandas networkx requests","title":"Installation"},{"location":"main/#usage","text":"To run the app, execute the following command in your terminal: python app.py This will start the Flask development server, and the app will be available at http://localhost:5000 .","title":"Usage"},{"location":"main/#api-endpoints","text":"","title":"API Endpoints"},{"location":"main/#_1","text":"This endpoint displays the home page of the app. It renders the index.html template and passes a list of station names to the template.","title":"/"},{"location":"main/#search","text":"This endpoint is triggered when the user submits the search form on the home page. It reads the user's inputs and performs a search for train paths between the specified start and end stations. The train data is downloaded from the SNCF API and stored in a pandas DataFrame. The search is then performed using the find_all_paths() function, which uses a recursive depth-first search algorithm to explore the train network graph. The search results are rendered in the search.html template and displayed to the user.","title":"/search"},{"location":"main/#function-find_all_paths","text":"This function takes in a network graph G , a start station name, an end station name, and the maximum number of hops, and returns a list of all paths between the start and end stations within the specified maximum number of hops. It uses a recursive depth-first search algorithm to explore the graph and find all possible paths. The algorithm keeps track of the number of hops made so far and the path taken. When the end station is reached, the current path is added to the list of all paths found.","title":"Function: find_all_paths()"},{"location":"main/#templates","text":"The app uses two HTML templates: index.html and search.html . The index.html template displays a form for the user to enter their search criteria, and a dropdown menu to select the start and end stations. The search.html template displays the search results in a table format.","title":"Templates"},{"location":"main/#dependencies","text":"This app has the following dependencies: Flask: A micro web framework for Python pandas: A library for data manipulation and analysis networkx: A library for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks requests: A library for making HTTP requests","title":"Dependencies"}]}