{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"draw/","text":"find_all_paths Function \u00b6 This function is used to find all paths from the start station to the end station in a given graph with a maximum number of hops. Parameters \u00b6 G (networkx.MultiDiGraph): The graph representing the train network. start_station (str): The name of the start station. end_station (str): The name of the end station. max_hops (int): The maximum number of hops allowed in the path. Returns \u00b6 all_paths (list): A list of all paths from the start station to the end station. Note: The function assumes that the graph G is already created and contains the necessary information about the train network. def find_all_paths(G, start_station, end_station, max_hops): # List to store all paths all_paths = [] # Recursive function to explore the graph def dfs(current_station, hops, path): # Base case: we've reached the end station if current_station == end_station: all_paths.append(path) hops = 0 return # Explore the neighbors of the current station for departure, neighbor, key in G.edges(current_station, keys=True): if neighbor not in [step[0] for step in path]: # Check if we've exceeded the maximum number of hops if hops < max_hops: if hops != 0: last_train_arrival_time = datetime.datetime.strptime(G[path[-2][0]][path[-1][0]][path[-1][2]][\"heure_arrivee\"], '%H:%M').time() else: last_train_arrival_time = datetime.datetime.strptime('00:00', '%H:%M').time() current_train_departure_time = datetime.datetime.strptime(G[current_station][neighbor][key][\"heure_depart\"], '%H:%M').time() if current_train_departure_time > last_train_arrival_time: dfs(neighbor, hops + 1, path + [(neighbor, current_train_departure_time, key)]) # Call the recursive function starting from the start station dfs(start_station, 0, [(start_station, datetime.time(0, 0), 0)]) return all_paths Example usage: start_station = \"MARSEILLE ST CHARLES\" end_station = \"LYON (intramuros)\" max_hops = 6 paths = find_all_paths(G, start_station, end_station, max_hops) if paths: for path in paths: print(f\"Path: {path}\") else: print(\"No paths found\")","title":"Draw"},{"location":"draw/#find_all_paths-function","text":"This function is used to find all paths from the start station to the end station in a given graph with a maximum number of hops.","title":"find_all_paths Function"},{"location":"draw/#parameters","text":"G (networkx.MultiDiGraph): The graph representing the train network. start_station (str): The name of the start station. end_station (str): The name of the end station. max_hops (int): The maximum number of hops allowed in the path.","title":"Parameters"},{"location":"draw/#returns","text":"all_paths (list): A list of all paths from the start station to the end station. Note: The function assumes that the graph G is already created and contains the necessary information about the train network. def find_all_paths(G, start_station, end_station, max_hops): # List to store all paths all_paths = [] # Recursive function to explore the graph def dfs(current_station, hops, path): # Base case: we've reached the end station if current_station == end_station: all_paths.append(path) hops = 0 return # Explore the neighbors of the current station for departure, neighbor, key in G.edges(current_station, keys=True): if neighbor not in [step[0] for step in path]: # Check if we've exceeded the maximum number of hops if hops < max_hops: if hops != 0: last_train_arrival_time = datetime.datetime.strptime(G[path[-2][0]][path[-1][0]][path[-1][2]][\"heure_arrivee\"], '%H:%M').time() else: last_train_arrival_time = datetime.datetime.strptime('00:00', '%H:%M').time() current_train_departure_time = datetime.datetime.strptime(G[current_station][neighbor][key][\"heure_depart\"], '%H:%M').time() if current_train_departure_time > last_train_arrival_time: dfs(neighbor, hops + 1, path + [(neighbor, current_train_departure_time, key)]) # Call the recursive function starting from the start station dfs(start_station, 0, [(start_station, datetime.time(0, 0), 0)]) return all_paths Example usage: start_station = \"MARSEILLE ST CHARLES\" end_station = \"LYON (intramuros)\" max_hops = 6 paths = find_all_paths(G, start_station, end_station, max_hops) if paths: for path in paths: print(f\"Path: {path}\") else: print(\"No paths found\")","title":"Returns"},{"location":"main/","text":"find_all_paths Function \u00b6 This function is used to find all paths from the start station to the end station in a given graph with a maximum number of hops. Parameters \u00b6 G (Graph): The graph representing the train network. start_station (str): The name of the start station. end_station (str): The name of the end station. max_hops (int): The maximum number of hops allowed in the path. Returns \u00b6 all_paths (list): A list of all paths from the start station to the end station. Note: The function assumes that the graph G is already created and contains the necessary information about the train network. index Function \u00b6 This function is the main route handler for the index page. It renders the index.html template with a sorted list of stations. Returns \u00b6 (render_template) The rendered HTML template. search Function \u00b6 This function is the route handler for the search page. It processes the user input, downloads the CSV file from the API, filters and processes the data, creates a graph, calls the find_all_paths function, and renders the search.html template with the paths. Returns \u00b6 (render_template) The rendered HTML template.","title":"Main"},{"location":"main/#find_all_paths-function","text":"This function is used to find all paths from the start station to the end station in a given graph with a maximum number of hops.","title":"find_all_paths Function"},{"location":"main/#parameters","text":"G (Graph): The graph representing the train network. start_station (str): The name of the start station. end_station (str): The name of the end station. max_hops (int): The maximum number of hops allowed in the path.","title":"Parameters"},{"location":"main/#returns","text":"all_paths (list): A list of all paths from the start station to the end station. Note: The function assumes that the graph G is already created and contains the necessary information about the train network.","title":"Returns"},{"location":"main/#index-function","text":"This function is the main route handler for the index page. It renders the index.html template with a sorted list of stations.","title":"index Function"},{"location":"main/#returns_1","text":"(render_template) The rendered HTML template.","title":"Returns"},{"location":"main/#search-function","text":"This function is the route handler for the search page. It processes the user input, downloads the CSV file from the API, filters and processes the data, creates a graph, calls the find_all_paths function, and renders the search.html template with the paths.","title":"search Function"},{"location":"main/#returns_2","text":"(render_template) The rendered HTML template.","title":"Returns"}]}